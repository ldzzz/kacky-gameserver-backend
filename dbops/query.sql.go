// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package dbops

import (
	"context"
	"database/sql"
)

const createUpdatePlayer = `-- name: CreateUpdatePlayer :exec
INSERT INTO tm_players (
  login, nickname, zone, game_type
) VALUES (
  ?,?,?,?
)
ON DUPLICATE KEY UPDATE nickname=VALUES(nickname), zone=VALUES(zone)
`

type CreateUpdatePlayerParams struct {
	Login    string         `json:"login"`
	Nickname sql.NullString `json:"nickname"`
	Zone     sql.NullString `json:"zone"`
	GameType sql.NullString `json:"game_type"`
}

func (q *Queries) CreateUpdatePlayer(ctx context.Context, arg CreateUpdatePlayerParams) error {
	_, err := q.exec(ctx, q.createUpdatePlayerStmt, createUpdatePlayer,
		arg.Login,
		arg.Nickname,
		arg.Zone,
		arg.GameType,
	)
	return err
}

const getPlayer = `-- name: GetPlayer :one
SELECT id, login, account_id, game_type, zone, total_finishes, nickname, role, is_muted, is_blacklisted, created_at, updated_at FROM tm_players
WHERE login = ? AND game_type = ?
`

type GetPlayerParams struct {
	Login    string         `json:"login"`
	GameType sql.NullString `json:"game_type"`
}

func (q *Queries) GetPlayer(ctx context.Context, arg GetPlayerParams) (TmPlayer, error) {
	row := q.queryRow(ctx, q.getPlayerStmt, getPlayer, arg.Login, arg.GameType)
	var i TmPlayer
	err := row.Scan(
		&i.ID,
		&i.Login,
		&i.AccountID,
		&i.GameType,
		&i.Zone,
		&i.TotalFinishes,
		&i.Nickname,
		&i.Role,
		&i.IsMuted,
		&i.IsBlacklisted,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlayerFinishes = `-- name: GetPlayerFinishes :many
SELECT finishes.id, finishes.map_id, finishes.player_id, finishes.score, finishes.finish_counter, finishes.created_at, finishes.updated_at, finishes.last_finished_at FROM finishes
JOIN tm_players ON finishes.player_id = tm_players.id
WHERE tm_players.login = ? AND tm_players.game_type = ?
`

type GetPlayerFinishesParams struct {
	Login    string         `json:"login"`
	GameType sql.NullString `json:"game_type"`
}

func (q *Queries) GetPlayerFinishes(ctx context.Context, arg GetPlayerFinishesParams) ([]Finish, error) {
	rows, err := q.query(ctx, q.getPlayerFinishesStmt, getPlayerFinishes, arg.Login, arg.GameType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Finish
	for rows.Next() {
		var i Finish
		if err := rows.Scan(
			&i.ID,
			&i.MapID,
			&i.PlayerID,
			&i.Score,
			&i.FinishCounter,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastFinishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
